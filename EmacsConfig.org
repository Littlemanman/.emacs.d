#+TITLE: LMM Emacs Config
#+AUTHOR: Lmm
#+STARTUP: content indent

* COMMENT OPEN DEBUG
#+begin_src emacs-lisp
(setq debug-on-error t)
#+end_src

* BOOT CONFIG
* CORE SETTINGS
** Adjust garbage collection thresholds during startup, and thereafter
垃圾回收
#+begin_src emacs-lisp
  (setq garbage-collection-messages t)
  (setq gc-cons-threshold (* 128 1024 1024))
  (setq gc-cons-percentage 0.6)
  (add-hook 'emacs-startup-hook
            (lambda () (setq gc-cons-threshold (* 20 1024 1024))))
  ;; (add-hook 'post-gc-hook (lambda ()(message "GC finished 🔥🔥🔥")))
#+end_src

** Fast Read
#+begin_src emacs-lisp
  ;; Increase how much is read from processes in a single chunk (default is 4kb)
  (setq read-process-output-max (* 4 1024 1024))
#+end_src

** COMMENT Init time
#+begin_src emacs-lisp
  (add-hook 'emacs-startup-hook
            (lambda ()
              (message "*** Emacs loaded in %s with %d garbage collections."
                       (format "%.2f seconds"
                               (float-time
                                (time-subtract after-init-time before-init-time)))
                       gcs-done)))
#+end_src

** Custom file
   #+begin_src emacs-lisp
     (setq custom-file (locate-user-emacs-file "custom.el"))
   #+end_src

** Open Config file
   #+begin_src emacs-lisp
     (defun open-init-file()
       (interactive)
       (find-file "~/.emacs.d/init.el"))
     (defun open-config-org-file()
       (interactive)
       (find-file "~/.emacs.d/EmacsConfig.org"))
     (global-set-key (kbd "<f2>") 'open-config-org-file)
   #+end_src

** Default Coding System
#+begin_src emacs-lisp
  (set-language-environment "UTF-8")
  (set-default-coding-systems 'utf-8)
#+end_src

** Server Mode
#+begin_src emacs-lisp
  (use-package server
    :ensure nil
    :config
    (server-start)
    )
#+end_src

** Native Comp Support
#+begin_src emacs-lisp
  ;; 判断是否支持native-comp
  (when (featurep 'native-compile)
    ;; 关闭native-comp 生成的警告
    (setq native-comp-async-report-warnings-errors nil)
    ;; 同步编译
    (setq native-comp-deferred-compilation t)
    ;; 自定义 native comp 缓存生成路径
    (add-to-list 'native-comp-eln-load-path (expand-file-name "eln-cache/" user-emacs-directory))
    (setq package-native-compile t))
#+end_src

** Yes Or No
#+begin_src emacs-lisp
  (setq use-short-answers t)
  (unless (>= emacs-major-version 28)
    (fset 'yes-or-no-p 'y-or-n-p))
  (setq y-or-n-p-use-read-key t
        ;;禁止切换从选择中出来
        read-char-choice-use-read-key t)
  ;; 更多的选项
  (defmacro lmm/read-char-choice (format choices)
    "More option to question. CHOICES is a list
     exp:
     (lmm/read-char-choice format ((?a (body)) (?b (body)) ...))"
            (declare (indent 1) (debug t))
            (let ((ch-list (mapcar (lambda (l)(car l)) choices)))
              `(let ((ch (read-char-choice ,format ',ch-list)))
                 (cond ,@(mapcar (lambda (c) (let ((c (car c))
                                            (body (cdr c)))
                                        (cons (list '= c 'ch) body))) choices)))))
#+end_src

** System Clipboard
#+begin_src emacs-lisp
  ;; 当变量为 t 时，evil 粘贴失效
  (setq select-enable-primary nil)
  ;; 开启系统剪贴板
  (setq select-enable-clipboard t)
#+end_src

** Enable Narrow Commands -- 只对目标进行编辑
#+begin_src emacs-lisp
  (put 'narrow-to-defun  'disabled nil)
  (put 'narrow-to-page   'disabled nil)
  (put 'narrow-to-region 'disabled nil)
#+end_src

* PACKAGE MANAGEMENT
** Setup package.el to work with MELPA.
   修改国内镜像源
   #+begin_src emacs-lisp
     (require 'package)
     (setq package-archives '(("gnu"   . "https://elpa.zilongshanren.com/gnu/")
                              ("melpa" . "https://elpa.zilongshanren.com/melpa/")
                              ("org" . "https://elpa.zilongshanren.com/org/")))
     ;; 合并 autoload io 快速启动，如果新安装包了之后需要执行 package-quickstart-refresh
     (setq package-quickstart t)
     ;; (package-refresh-contents)
   #+end_src

** Installing use-package
包管理器
#+begin_src emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-initialize)
    (package-refresh-contents)
    (package-install 'use-package))
  (setq use-package-hook-name-suffix nil) ;;停止在:hook 当中添加-hook后缀
  ;; 启动时显示包加载信息至 *Message*
  ;; (setq use-package-verbose t)
  (eval-when-compile
    (require 'use-package))
#+end_src

** COMMENT Use-Package Man
    #+begin_src emacs-lisp
      (use-package some-package-name
        :disabled ;;停止加载不使用的内容
        :no-require t; 不加载
        :ensure t ;;确保软件包会自动安装
        :defer t ;;延迟t秒加载包（require 'some-package-name)
        :init () ;;加载包之前执行的代码
        :config () ;;加载包之后执行的代码
        :hook () ;;钩子, 默认启用 defer t
        :commands command-example ;;延迟加载，命令触发
        )
    #+end_src

** Install diminish, bind-key, gcmh
#+begin_src emacs-lisp
  (use-package diminish
    :ensure t
    )
  (use-package bind-key
    :ensure t)

  ;; 垃圾回收
  (use-package gcmh
    :ensure t
    :config
    (gcmh-mode))
#+end_src

* HELP
** Helpful -- 更好的帮助信息
#+begin_src emacs-lisp
  (use-package helpful
    :ensure t
    :bind
    (:map help-map
          ("SPC" . helpful-at-point)
          ("f" . helpful-callable)
          ("F" . helpful-function)
          ("v" . helpful-variable)
          ("k" . helpful-key)
          ("C" . helpful-command)))
#+end_src
* KEY BIND
** Simple Key Bind
[[https://github.com/noctuid/general.el][General]] 直观的按键绑定
#+begin_src emacs-lisp
  (use-package general
    :ensure t
    :config
    (general-evil-setup t))
#+end_src
#+begin_src emacs-lisp
  ;; ESC Cancels All
  (global-set-key (kbd "<escape>") 'keyboard-escape-quit)

  ;; Rebind C-u
  (global-set-key (kbd "C-M-u") 'universal-argument)
#+end_src
** Hydra
#+begin_src emacs-lisp
  (use-package hydra
    :ensure t
    :config)
#+end_src
** Mouse Key Bind
* UI
** Disable Menu, Toolbar, Scrollbar, Starup Screen
   #+begin_src emacs-lisp
     (menu-bar-mode -1)
     (tool-bar-mode -1)
     (scroll-bar-mode -1)
     (tooltip-mode -1)
     ;; 禁止启动屏幕
     (setq inhibit-startup-message t)
   #+end_src

** Display Line Numbers and Truncated Lines
#+begin_src emacs-lisp
  (global-visual-line-mode t)

  (setq-default display-line-numbers-type 'relative
        display-line-numbers-width 3
        display-line-numbers-widen t)
  ;; Enable line numbers for some modes
  ;; 开启行号显示
  (dolist (mode '(text-mode-hook
                  prog-mode-hook
                  conf-mode-hook))
    (add-hook mode (lambda () (display-line-numbers-mode 1))))

  ;; Override some modes which derive from the above
  (dolist (mode '(org-mode-hook))
    (add-hook mode (lambda () (display-line-numbers-mode 0))))
  ;; 设置相对行号


  ;; (use-package simple
  ;;   :ensure nil
  ;;   :config
  ;;   (progn
  ;;     ;; 关闭当前行高亮
  ;;     (global-hl-line-mode -1)))
   #+end_src

** Cursor Face
#+begin_src emacs-lisp
  (setq blink-cursor-mode t)
  (defun lmm/cursor-I-am-here ()
    "cursor, where are you ???"
    (interactive)
    )
#+end_src

** Bell
*** COMMENT bell modeline color
   #+begin_src emacs-lisp
     (setq ring-bell-function
           (lambda ()
             (let ((orig-fg (face-background 'mode-line)))
               (set-face-background 'mode-line "#a8910f")
               (run-with-idle-timer 0.1 nil
                                    (lambda (fg) (set-face-background 'mode-line fg))
                                    orig-fg))))
   #+end_src
*** visible bell
#+begin_src emacs-lisp
  (setq visible-bell nil)
#+end_src

** 80 line
#+begin_src emacs-lisp
  (when (boundp 'display-fill-column-indicator)
    (setq-default indicate-buffer-boundaries 't)
    (setq-default fill-column 80)
    (add-hook 'prog-mode-hook 'display-fill-column-indicator-mode))
#+end_src

** Icon Display
#+begin_src emacs-lisp
  (use-package all-the-icons
    :ensure t)
#+end_src

** Dashboard
#+begin_src emacs-lisp
  (use-package dashboard
    :ensure t
    ;; :hook (after-init-hook . dashboard-setup-startup-hook)
    :init
    ;; 居中对齐
    (setq dashboard-center-content t)
    ;;(setq dashboard-show-shortcuts nil)
    (setq dashboard-items '((recents  . 5)
                            (projects . 5)
                            (bookmarks . 5)
                            (agenda . 5)
                            (registers . 5)))
    ;; 启用图标
    (setq dashboard-set-heading-icons t)
    (setq dashboard-set-file-icons t)
    ;; 主页设置
    ;; (setq dashboard-set-navigator t)
    ;; Format: "(icon title help action face prefix suffix)"
    ;; (setq dashboard-navigator-buttons
    ;;       `(;; line1
    ;;         ((,(all-the-icons-octicon "mark-github" :height 1.1 :v-adjust 0.0)
    ;;           "Homepage"
    ;;           "Browse homepage"
    ;;           (lambda (&rest _) (browse-url "homepage")))
    ;;          ("★" "Star" "Show stars" (lambda (&rest _) (show-stars)) warning)
    ;;          ("?" "" "?/h" #'show-help nil "<" ">"))
    ;;         ;; line 2
    ;;         ((,(all-the-icons-faicon "linkedin" :height 1.1 :v-adjust 0.0)
    ;;           "Linkedin"
    ;;           ""
    ;;           (lambda (&rest _) (browse-url "homepage")))
    ;;          ("⚑" nil "Show flags" (lambda (&rest _) (message "flag")) error))))
    :config
    ;;启用dashboard
    (dashboard-setup-startup-hook)
    ;; emacsclient启动时为dashboard
    (setq initial-buffer-choice '(lambda () (get-buffer "*dashboard*")))
    )
#+end_src

** Posframe
#+begin_src emacs-lisp
  (use-package posframe
    :ensure t
    :defer t
    )
#+end_src
** Face Theme
#+begin_src emacs-lisp
  (use-package doom-themes
    :ensure t
    :config
    ;; Global settings (defaults)
    (setq doom-themes-enable-bold t    ; if nil, bold is universally disabled
          doom-themes-enable-italic t) ; if nil, italics is universally disabled
    (load-theme 'doom-dracula t)
    ;; (doom-themes-visual-bell-config)
   )
#+end_src

** Modeline Config
#+begin_src emacs-lisp
  (use-package doom-modeline
    :ensure t
    :hook
    (after-init-hook . doom-modeline-mode))
#+end_src

** Pair Color Config
#+begin_src emacs-lisp
  (use-package rainbow-delimiters
    :ensure t
    :hook
    (prog-mode-hook . rainbow-delimiters-mode))
#+end_src

** Fonts
#+begin_src emacs-lisp
  ;; 字体设置
  (set-face-attribute 'default nil
                      :font "Fira Code"
                      ;; :slant 'normal
                      ;; :weight 'normal
                      :height 130
                      ;; :width 'normal
                      )
  (add-to-list 'default-frame-alist '(font . "Fira Code"))

  ;; (set-face-attribute 'default nil
  ;;                     :font "Sarasa Mono SC Nerd"
  ;;                     ;; :slant 'normal
  ;;                     ;; :weight 'normal
  ;;                     :height 130
  ;;                     ;; :width 'normal
  ;;                     )
  ;; (add-to-list 'default-frame-alist '(font . "Sarasa Mono SC Nerd"))


  (defhydra hydra-text-scale()
    "Change font size"
    ;; 减小字体
    ("j" text-scale-increase "Text Scale Increase")
    ;; 增大字体
    ("k" text-scale-decrease "Text Scale Decrease")
    ;; text-scale-adjust 按键监听，＋ － 或 0 重置，q 退出
    ("q" nil "Quit ! ! !"))

  ;; (global-prettify-symbols-mode t)
  ;; (dolist (hook '(prog-mode-hook
  ;;                org-mode-hook))
  ;;         (add-hook hook 'prettify-symbols-mode))
#+end_src

** Whitespace Config
#+begin_src emacs-lisp
  (setq-default show-trailing-whitespace nil)
  (defun Lmm/show-trailing-whitespace()
    "Enable display of trailing whitespace in this buffer."
    (setq-local show-trailing-whitespace t))
  (dolist (hook '(prog-mode-hook text-mode-hook conf-mode-hook))
          (add-hook hook 'Lmm/show-trailing-whitespace))
#+end_src

** COMMENT Symbol Highlight
#+begin_src emacs-lisp
  (use-package auto-highlight-symbol
    :ensure t)
#+end_src

** Beautiful Code
*** COMMENT svg-tag-mode
#+begin_src emacs-lisp
  (use-package svg-tag-mode
    :disabled
    :no-require t
    :ensure t
    :config
    (setq svg-tag-tags
          '(
            (":TODO:" . ((lambda (tag) (svg-tag-make tag :beg 1 :end -1))))
            )))
#+end_src

*** hl-todo
#+begin_src emacs-lisp
  (use-package hl-todo
    :ensure t
    :hook
    (after-init-hook . global-hl-todo-mode))
#+end_src

*** COMMENT highlight indent
#+begin_src emacs-lisp

#+end_src

* EVIL MODE
** Evil Core
#+begin_src emacs-lisp
  (use-package evil
    :ensure t
    :init
    ;;
    (setq evil-want-integration t
          ;; 在其他模式加载vim默认键绑定
          evil-want-keybinding nil
          evil-vsplit-window-right t
          evil-split-window-below t
          evil-want-C-u-delete t
          evil-want-C-u-scroll t
          evil-want-C-w-delete t
          evil-want-C-i-jump t
          evil-want-Y-yank-to-eol t
          ;; undo-tree时会出现未知卡顿
          evil-undo-system 'undo-redo
          ;; 禁止在 ex 命令当中补全 emacs 命令
          evil-ex-complete-emacs-commands nil
          ;; 使用 emacs 本身的撤销模式
          evil-want-fine-undo t
          ;; 粘贴替换选中文本不加入 kill ring 中
          evil-kill-on-visual-paste nil)
    :hook
    (after-init-hook . evil-mode)
    :config
    (general-define-key
     :states 'insert
     "j" (general-key-dispatch 'self-insert-command
           :timeout 0.1
           "k" 'evil-normal-state
           "l" 'toggle-input-method))
    ;; 自定义 escape
    (defun lmm/evil-escape ()
      (when (evil-insert-state-p)
        (let* ((modified (buffer-modified-p))
               (fkey "j")
               (skey "k")
               (evt (read-event nil nil 0.2)))
          (cond ((and (characterp evt)
                      (equal fkey (this-command-keys))
                      (equal skey (char-to-string evt)))
                 (delete-char -1)
                 (set-buffer-modified-p modified)
                 (evil-normal-state))
                ((null evt))
                (t (setq unread-command-events
                         (append unread-command-events (list evt))))))))

    (setq evil-emacs-state-modes nil)
    (setq evil-insert-state-modes nil)
    (setq evil-motion-state-modes nil)

    (setq evil-visual-state-cursor 'hollow)
    ;;清空插入模式的按键
    ;; (setcdr evil-insert-state-map nil)
    ;; 定制ex命令
    (evil-ex-define-cmd "q" 'kill-this-buffer)
    ;; (evil-set-leader 'normal (kbd "<SPC>"))

    (general-define-key
     :states '(normal motion)
     "," evil-window-map)

    (general-define-key
     :states '(normal motion)
     "gh" 'beginning-of-line-text
     "gl" 'end-of-line
     )

    (general-create-definer lmm/evil-space-leader-def
      :states '(normal motion)
      :keymaps 'override
      :prefix-command 'lmm/evil-space-leader-def-command
      :prefix-map 'lmm/evil-space-leader-def-map
      :prefix "SPC")
    (lmm/evil-space-leader-def
      "w" evil-window-map
      "," 'switch-to-buffer
      "<" 'switch-to-buffer
      "si" 'imenu
      "ff" 'find-file
      "fb" 'switch-to-buffer
      "fr" 'recentf-open-files
      "fw" 'save-buffer
      "fs" 'save-buffer
      "qq" 'save-buffers-kill-terminal
      "qs" 'evil-save-and-quit
      "es" 'eval-last-sexp
      "ed" 'eval-defun
      "er" 'eval-region
      "eb" 'eval-buffer
      "ep" 'eval-print-last-sexp
      "bk" 'kill-current-buffer)
    ;; (evil-set-leader '(normal motion) (kbd "C-SPC"))

    ;; (evil-define-key '(normal motion) 'global (kbd ""))

    ;; (evil-define-key '(normal motion) 'global
    ;;   (kbd "<leader>w") 'evil-window-map)

    ;; (defvar lmm/leader-search-map (make-sparse-keymap)
    ;;   "Keymap for \"leader key /\" shortcuts.")
    ;; (define-key lmm/leader-search-map "/" evil-search-forward)

    ;; (evil-define-key '(normal motion visual) 'global
    ;;   "/" lmm/leader-search-map)

    ;; (define-key lmm/leader-search-map "/" 'evil-search-forward)
    ;; (define-key lmm/leader-search-map "?" 'evil-search-backward)
    ;; (define-key lmm/leader-search-map "l" 'consult-line)
    ;; (define-key lmm/leader-search-map "i" 'consult-imenu)
    ;; (define-key lmm/leader-search-map "o" 'consult-outline)

    ;; (defvar lmm/leader-comma-map (make-sparse-keymap)
    ;;   "Keymap for \"leader key ,\" shortcuts.")
    ;; (evil-define-key 'normal 'global
    ;;   ";" lmm/leader-comma-map)
    :bind
    (:map evil-insert-state-map
          ("C-a" . beginning-of-visual-line)
          ("C-e" . end-of-visual-line)
          ("C-h" . backward-delete-char)
          ("C-d" . delete-char)
          ;; ("C-p" . previous-line)
          ;; ("C-n" . next-line)
          ("C-g" . evil-normal-state)
          :map evil-normal-state-map
          ("f" . evil-avy-goto-char-2)
          ("F" . evil-avy-goto-word-1)
          ("'" . evil-goto-mark)
          ("`" . evil-goto-mark-line)
          ;; ("<leader>ff" . find-file)
          ;; ("<leader>bb" . switch-to-buffer)
          ;; ("<leader>bs" . evil-split-buffer)
          ;; ("<leader>bl" . ibuffer)
          ;; ("<leader>bd" . evil-delete-buffer)
          ;; ("<leader>bk" . kill-buffer)
          ;; ("<leader>bp" . previous-buffer)
          ;; ("<leader>bn" . next-buffer)
          ;; ("<leader>w" . evil-window-map)
          :map evil-motion-state-map
          ("f" . evil-avy-goto-char-in-line)
          ("F" . evil-avy-goto-word-1)
          ("'" . evil-goto-mark)
          ("`" . evil-goto-mark-line)
          :map evil-window-map
          ("d" . kill-buffer-and-window)
          ("SPC" . switch-to-buffer)))
#+end_src
** COMMENT Evil-Escape
#+begin_src emacs-lisp
  (use-package evil-escape
    :disabled
    :no-require t
    :ensure t
    :hook
    (evil-mode-hook . evil-escape-mode)
    :init
    (setq-default evil-escape-key-sequence "jk")
    ;; 只在指定主模式当中启用
    ;; (setq evil-escape-enable-only-for-major-modes '(prog-mode
    ;;                                                 org-mode
    ;;                                                 org-src-mode
    ;;                                                 emacs-lisp-mode
    ;;                                                 ))
    ;; 只在指定主模式当中禁用
    (setq-default evil-escape-excluded-major-modes '(help-mode
                                                     ibuffer-mode
                                                     dired-mode
                                                     Info-mode
                                                     undo-tree-mode))

    (add-hook 'magit-mode-hook (lambda ()
                                 (setq-local evil-escape-inhibit t)))
    ;; 当表中的函数返回非 nil 时禁止使用
    (setq evil-escape-inhibit-functions '(evil-visual-state-p))
    :diminish evil-escape-mode
    )
#+end_src

** Other Evil Plugins
#+begin_src emacs-lisp
  ;; 更多的按键绑定
  (use-package evil-collection
    :ensure t
    :hook
    (evil-mode-hook . evil-collection-init))

  ;; 注释
  (use-package evil-nerd-commenter
    :ensure t
    :after evil
    ;; :bind
    ;; (:map lmm/leader-comma-map
    ;;       (";" . evilnc-comment-operator)
    ;;       ("l" . evilnc-comment-or-uncomment-lines))
    :config
    (defun lmm/comment-dwim-auto-insert (arg)
      "comment line or mark region, if evil normal state auto toggle insert state"
      (interactive "*P")
      (comment-dwim arg)
      (if evil-normal-state-minor-mode
          (evil-append 0)))

    (general-define-key
     :states 'normal
     "M-;" 'comment-dwim)

    (general-define-key
     :states 'normal
     "gc" (general-key-dispatch 'evilnc-comment-operator
            "l" 'evilnc-comment-or-uncomment-lines)))

  ;; 括号修改
  (use-package evil-surround
    :ensure t
    :hook
    (org-mode-hook . evil-surround-mode)
    (prog-mode-hook . evil-surround-mode))

  ;; 撤销树
  (use-package undo-tree
    :ensure t
    :hook
    (evil-mode-hook . global-undo-tree-mode)
    :bind
    (:map undo-tree-visualizer-mode-map
          ("l" . undo-tree-visualize-switch-branch-right)
          ("h" . undo-tree-visualize-switch-branch-left)))
  ;; C-x u 会出来一个撤销树可供选择以前的一些编辑状态
  ;; 可按 d 进行 diff 对比

  ;; 交换标记区域
  (use-package evil-exchange
    :ensure t
    :after evil
    :config
    (general-define-key
     :states 'normal
     "gx" 'evil-exchange
     "gX" 'evil-exchange-cancel))

  ;; 参数跳转与修改
  (use-package evil-args
    :ensure t
    :after evil
    :bind
    (:map evil-inner-text-objects-map
          ("a" . evil-inner-arg)
          :map evil-outer-text-objects-map
          ("a" . evil-outer-arg)
          :map evil-normal-state-map
          ("[a" . evil-backward-arg)
          ("]a" . evil-forward-arg)
          :map evil-motion-state-map
          ("[a" . evil-backward-arg)
          ("]a" . evil-forward-arg)
          )
    )

  ;; 快速跳转
  (use-package evil-snipe
    :disabled
    :no-require t
    :ensure t
    :hook
    (evil-mode-hook . evil-snipe-mode)
    :init
    (setq evil-snipe-scope 'line
          evil-snipe-repeat-scope 'visible)
    :bind
    (:map evil-normal-state-map
          ("f" . evil-snipe-f)
          ("F" . evil-snipe-F)
          ("s" . evil-snipe-s)
          ("S" . evil-snipe-S))
    )
  #+end_src

** Other Evil EditUtils
#+begin_src emacs-lisp
  (use-package evil
    :ensure nil
    :config
    ;; 删除当前行光标前所有空格
    (general-define-key
     :keymaps 'evil-outer-text-objects-map
     "SPC" (lambda ()(interactive) (cycle-spacing 0)))
    ;; 删除当前行光标前空格，保留一个
    (general-define-key
     :keymaps 'evil-inner-text-objects-map
     "SPC" 'cycle-spacing)

    (evil-define-command evil-vsplit-next-buffer (&optional count)
      "Vsplits the window and goes to the COUNT-th next buffer in the buffer list."
      :repeat nil
      (interactive "p")
      (evil-window-vsplit)
      (evil-next-buffer count))

    (evil-define-command evil-vsplit-prev-buffer (&optional count)
      "Vsplits window and goes to the COUNT-th prev buffer in the buffer list."
      :repeat nil
      (interactive "p")
      (evil-window-vsplit)
      (evil-prev-buffer count))

    (general-define-key
     :keymaps 'evil-window-map
     "s" 'evil-split-next-buffer
     "v" 'evil-vsplit-next-buffer)
    )
#+end_src

* WINDOW AND BUFFER AND FRAME
** Utils Functions
#+begin_src emacs-lisp
  (defun lmm/kill-current-buffer-and-window ()
    "kill current buffer and window, if just one window, kill current buffer"
    (interactive)
    (if (and (window-full-width-p) (window-full-height-p))
        (kill-current-buffer)
      (kill-buffer-and-window)))

  (use-package evil
    :ensure nil
    :bind
    (:map evil-window-map
          ("d" . kill-this-buffer)
          ("D" . lmm/kill-current-buffer-and-window)))
#+end_src
** Window Split Config
#+begin_src emacs-lisp
  ;; 窗口布局历史切换
  (use-package winner
    :ensure nil
    :after evil
    :config
    (winner-mode)
    (define-key evil-window-map "u" 'winner-undo)
    (define-key evil-window-map "U" 'winner-redo))

  ;; 尽可能重用现有buffer
  ;; (customize-set-variable 'display-buffer-base-action
  ;;                         '((display-buffer-reuse-window display-buffer-same-window)
  ;;                           (reusable-frames . t)))
  ;; (customize-set-variable 'even-window-sizes nil)

  (if (display-graphic-p)
      (progn
        (setq initial-frame-alist
              '((width . 200)
                (height . 50)
                (left . 100)
                (top . 50)))
        (setq default-frame-alist
              '((width . 200)
                (height . 50)
                (left . 100)
                (top . 50)))))
#+end_src
** Window Jump Config
#+begin_src emacs-lisp
  (use-package ace-window
    :ensure t
    :custom
    (aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
    (aw-background nil)
    :hook
    (after-init-hook . ace-window-display-mode)
    :config
    (general-define-key
     :keymaps 'evil-window-map
     "." 'ace-window
     "," 'evil-window-mru))
#+end_src
** Buffers Config
#+begin_src emacs-lisp
  (use-package fullframe
    :disabled
    :no-require t
    :after
    (fullframe ibuffer ibuffer-quit))
  (use-package ibuffer
    :ensure nil
    :init
    (setq ibuffer-formats
          '((mark modified read-only vc-status-mini " "
                  (name 22 22 :left :elide)
                  " "
                  (size-h 9 -1 :right)
                  " "
                  (mode 12 12 :left :elide)
                  " "
                  vc-relative-file)
            (mark modified read-only vc-status-mini " "
                  (name 22 22 :left :elide)
                  " "
                  (size-h 9 -1 :right)
                  " "
                  (mode 14 14 :left :elide)
                  " "
                  (vc-status 12 12 :left)
                  " "
                  vc-relative-file)))

    (setq ibuffer-filter-group-name-face 'font-lock-doc-face)
    :config
    (global-set-key [remap list-buffers] 'ibuffer)
    (define-ibuffer-column size-h
      (:name "Size" :inline t)
      (file-size-human-readable (buffer-size)))
    )
  (use-package ibuffer-vc
    :ensure t
    :config
    (defun ibuffer-set-up-preferred-filters ()
      (ibuffer-vc-set-filter-groups-by-vc-root)
      (unless (eq ibuffer-sorting-mode 'filename/process)
        (ibuffer-do-sort-by-filename/process)))

    (add-hook 'ibuffer-hook 'ibuffer-set-up-preferred-filters)

    (setq-default ibuffer-show-empty-filter-groups nil)
    )
#+end_src
** POPUP WINDOW MANAGER
#+begin_src emacs-lisp
  (use-package popwin
    :ensure t
    :hook
    (after-init-hook . popwin-mode)
    :config
    (push '("^\\*Org Src.*\\*$" :regexp t :position bottom) popwin:special-display-config)
    (push '("^\\*cargo-run.*\\*$" :regexp t :position bottom) popwin:special-display-config)
    (push '("^\\*cargo-clippy.*\\*$" :regexp t :position bottom) popwin:special-display-config)
    (push '("^\\*Help.*\\*$" :regexp t :position bottom) popwin:special-display-config)
    )
#+end_src
** Frame Config
#+begin_src emacs-lisp
#+end_src
** Auto Save Window Size
自动保存窗口尺寸
#+begin_src emacs-lisp
  (use-package desktop
    :defer t
    :init
    (setq desktop-path (list user-emacs-directory)
          desktop-auto-save-timeout 600)
    :hook
    (window-setup-hook . desktop-save-mode))
#+end_src
* WHICH KEY
  #+begin_src emacs-lisp
    (use-package which-key
      :ensure t
      :hook
      (after-init-hook . which-key-mode)
      :diminish which-key-mode
      )
  #+end_src

* MINIBUFFER
** Minibuffer
#+begin_src emacs-lisp
  ;; 在 minibuffer 中执行 minibuffer
  (setq enable-recursive-minibuffers t)
  ;; 禁止光标移动到提示文本上
  (customize-set-variable 'minibuffer-prompt-properties '(read-only t cursor-intangible t face minibuffer-prompt))
#+end_src
** Vertico -- 命令完成
#+begin_src emacs-lisp
  ;; minibuffer命令记录数量
  (setq-default history-length 1000)
  ;;命令历史
  (use-package savehist
    :ensure nil
    :init
    (setq vertico-count 15)
    :hook
    (after-init-hook . savehist-mode))
  (use-package vertico  ;;命令补全
    :ensure t
    :hook
    (after-init-hook . vertico-mode)
    (minibuffer-setup-hook . vertico-repeat-save)
    :bind
    (:map vertico-map
          ("C-w" . backward-kill-word)
          ("C-r" . consult-history)
          ("C-h" . vertico-directory-delete-char)
          ("C-w" . vertico-directory-delete-word)
          ("M-<backspace>" . vertico-directory-up)
          ("C-<backspace>" . vertico-directory-up)
          ("C-u" . evil-delete-back-to-indentation))
    :config
    (lmm/evil-space-leader-def
      "x" 'vertico-repeat))
  (use-package orderless  ;;搜索排序
    :ensure t
    :after vertico
    :init
    (setq completion-styles '(orderless)
          completion-category-defaults nil
          completion-category-overrides '((file (styles partial-completion))))
    )
  (use-package marginalia  ;;命令注释
    :ensure t
    :after vertico
    :config
    (marginalia-mode)
    )
#+end_src
** Consult -- 搜索完成
#+begin_src emacs-lisp
  (use-package consult
    :ensure t
    :after vertico
    :config
    (global-set-key (kbd "M-Y") 'consult-yank-from-kill-ring)
    (global-set-key [remap switch-to-buffer] 'consult-buffer)
    (global-set-key [remap switch-to-buffer-other-window] 'consult-buffer-other-window)
    (global-set-key [remap switch-to-buffer-other-frame] 'consult-buffer-other-frame)
    (global-set-key [remap goto-line] 'consult-goto-line)
    (consult-customize
     consult-ripgrep consult-git-grep consult-grep
     consult-bookmark consult-recent-file consult-xref
     consult--source-recent-file consult--source-project-recent-file consult--source-bookmark
     :preview-key (kbd "M-."))
    (advice-add #'completing-read-multiple
                :override #'consult-completing-read-multiple)
    ;; 替换系统完成
    (setq completion-in-region-function
          (lambda (&rest args)
            (apply (if vertico-mode
                       #'consult-completion-in-region
                     #'completion--in-region)
                   args)))

    (defun lmm/consult-symbol-at-point (&optional n)
      "get symbol at current point, search geted symbol at consult-line"
      (interactive)
      (consult-line (thing-at-point 'symbol)))
    (defun lmm/consult-symbol-at-point-multi (&optional n)
      "get symbol at current point, search geted symbol at consult-line-multi"
      (interactive)
      (consult-line-multi nil (thing-at-point 'symbol)))

    (defun lmm/consult-word-at-point (&optional n)
      "get word at current point, search geted word at consult-line"
      (interactive)
      (consult-line (thing-at-point 'word)))
    (defun lmm/consult-word-at-point-multi (&optional n)
      "get word at current point, search geted word at consult-line-multi"
      (interactive)
      (consult-line-multi nil (thing-at-point 'word)))

    (defun lmm/consult-number-at-point (&optional n)
      "get number at current point, search geted number at consult-line"
      (interactive)
      (consult-line (if-let ((n (number-at-point)))
                        (number-to-string n)
                      nil)))
    (defun lmm/consult-number-at-point-multi (&optional n)
      "get number at current point, search geted number at consult-line-multi"
      (interactive)
      (consult-line-multi nil (if-let ((n (number-at-point)))
                                  (number-to-string n)
                                nil)))

    (lmm/evil-space-leader-def
      "sb" 'consult-line
      "sB" 'consult-line-multi
      "s.s" 'lmm/consult-symbol-at-point
      "s.S" 'lmm/consult-symbol-at-point-multi
      "s.w" 'lmm/consult-word-at-point
      "s.W" 'lmm/consult-word-at-point-multi
      "s.n" 'lmm/consult-number-at-point
      "s.N" 'lmm/consult-number-at-point-multi
      "si" (lambda ()(interactive) (if (eq major-mode 'org-mode)(consult-org-heading)(consult-imenu)))
      "sI" 'consult-imenu-multi
      "fr" 'consult-recent-file
      )
    )
  (use-package consult-flycheck
    :ensure t
    :after consult
    )
#+end_src

** Embark -- 上下文菜单
#+begin_src emacs-lisp
  (use-package embark   ;;
    :ensure t
    :after vertico
    :init
    :bind
    (("C-;". embark-act)
     :map vertico-map
          ("C-." . (lambda ()(interactive)
                     (let ((embark-quit-after-action nil))
                                             (embark-act))))
          ;; 导出当前列表到额外buffer，然后执行各种操作
          ("C-;" . embark-act)
          ("C-c C-o" . embark-export)
          )
    :config
    ;; embark menu with which key
    (defun embark-which-key-indicator ()
      "An embark indicator that displays keymaps using which-key.
  The which-key help message will show the type and value of the
  current target followed by an ellipsis if there are further
  targets."
      (lambda (&optional keymap targets prefix)
        (if (null keymap)
            (which-key--hide-popup-ignore-command)
          (which-key--show-keymap
           (if (eq (plist-get (car targets) :type) 'embark-become)
               "Become"
             (format "Act on %s '%s'%s"
                     (plist-get (car targets) :type)
                     (embark--truncate-target (plist-get (car targets) :target))
                     (if (cdr targets) "¡­" "")))
           (if prefix
               (pcase (lookup-key keymap prefix 'accept-default)
                 ((and (pred keymapp) km) km)
                 (_ (key-binding prefix 'accept-default)))
             keymap)
           nil nil t (lambda (binding)
                       (not (string-suffix-p "-argument" (cdr binding))))))))

    (setq embark-indicators
          '(embark-which-key-indicator
            embark-highlight-indicator
            embark-isearch-highlight-indicator))

    (defun embark-hide-which-key-indicator (fn &rest args)
      "Hide the which-key indicator immediately when using the completing-read prompter."
      (which-key--hide-popup-ignore-command)
      (let ((embark-indicators
             (remq #'embark-which-key-indicator embark-indicators)))
        (apply fn args)))

    (advice-add #'embark-completing-read-prompter
                :around #'embark-hide-which-key-indicator)
    )
  (use-package embark-consult
    :ensure t
    :after (embark consult)
    :demand t
    :hook
    (embark-collect-mode . consult-preview-at-point-mode))
#+end_src

* ORG MODE CONFIG
#+begin_src emacs-lisp
  (use-package org
    :ensure nil
    :commands org-mode
    :config
    (set-face-attribute 'org-block nil :foreground nil)
    )

  (use-package tempo
    :ensure nil
    :config
    (require 'org-tempo)
    (tempo-define-template "org-src"
                           '("#+begin_src " p '> n nil "#+end_src" >)))

  (use-package org-superstar
    :ensure t
    :hook
    (org-mode-hook . org-superstar-mode))

  (use-package evil-org
    :ensure t
    :hook
    (org-mode-hook . evil-org-mode))
#+end_src
* EDIT SETTINGS
** Newline
#+begin_src emacs-lisp
  (defun lmm/newline(&optional arg interactive)
    (interactive "*P\np")
    (if (and (looking-at-p "}")
             (save-excursion
               (goto-char (1- (point)))
               (looking-at-p "{")))
        (progn
          (save-excursion
            (newline arg interactive))
          (newline arg interactive)
          )
      (newline arg interactive)))
#+end_src
** Search -- anzu
#+begin_src emacs-lisp
  (use-package anzu
    :ensure t
    :hook
    (after-init-hook . global-anzu-mode))
#+end_src

*** Evil-auzu
#+begin_src emacs-lisp
  (use-package evil-anzu
    :ensure t
    :after evil anzu
    )
#+end_src

** Keyboard Input -- 中文输入
#+begin_src emacs-lisp
  (use-package pyim
    :ensure t
    :commands toggle-input-method
    :init
    (setq default-input-method "pyim")
    :config
    (pyim-default-scheme 'quanpin)
    ;; (setq pyim-dicts
    ;;       `((:name "Greatdict" :file ,(concat user-emacs-directory "pyim/dicts/pyim-greatdict.pyim"))))

    (general-define-key
     :keymaps 'pyim-mode-map
     "," 'pyim-previous-page
     "." 'pyim-next-page
     "j" (general-key-dispatch (lambda () (interactive)
                                 (pyim-self-insert-command))
           :timeout 0.1
           "k" (lambda () (interactive)
                 (pyim-quit-clear)
                 (evil-normal-state))
           "l" (lambda () (interactive)
                 (pyim-quit-clear)
                 (toggle-input-method))))


    (let* ((file (concat user-emacs-directory "pyim/dicts/pyim-greatdict.pyim.gz")))
      (if (file-exists-p file)
          (if (featurep 'pyim)
              (pyim-extra-dicts-add-dict
               `(:name "Greatdict"
                       :file ,file
                       :coding utf-8-unix
                       :dict-type pinyin-dict
                       ))
            (message "pyim not install !!!"))
        (message (format "pyim dict file \"%s\" not found !!!" file))))


  ;; (let* ((dictspath (concat user-emacs-directory "pyim/dicts"))
  ;;        (dictfiles (directory-files dictspath)))
  ;;   (if dictfiles
  ;;       ()))
  )

#+end_src
** Default Variable -- 系统默认变量
   #+begin_src emacs-lisp
     (setq-default
      create-lockfiles nil                   ;; 创建锁定文件以防止其他用户同时编辑 , just like #filename
      inhibit-compacting-font-caches t
      bookmark-default-file (expand-file-name ".bookmarks.el" user-emacs-directory)
      buffers-menu-max-size 30
      case-fold-search t
      column-number-mode t
      ediff-split-window-function 'split-window-horizontally
      ediff-window-setup-function 'ediff-setup-windows-plain
      ;; 禁用TAB代替空白缩进
      indent-tabs-mode nil
      make-backup-files nil
      mouse-yank-at-point t
      save-interprogram-paste-before-kill t
      scroll-preserve-screen-position 'always
      scroll-conservatively 1000
      set-mark-command-repeat-pop t
      tooltip-delay 1.5
      truncate-lines nil
      truncate-partial-width-windows nil
      ;; 行上下边距
      scroll-margin 0
      ;; 列左右边距
      visual-line-fringe-indicators '(nil right-curly-arrow)
      )
   #+end_src

** Default Mode -- 系统默认模式
*** 自动加载文件
    #+begin_src emacs-lisp
      (add-hook 'after-init-hook 'global-auto-revert-mode)
      (setq global-auto-revert-non-file-buffers t
            auto-revert-verbose nil)
      (diminish 'auto-revert-mode)
    #+end_src
*** 长行文件性能缓解
#+begin_src emacs-lisp
  (use-package so-long
    :ensure nil
    :hook
    (after-init-hook . global-so-long-mode))
#+end_src
*** 选中文字输入替换
#+begin_src emacs-lisp
  (delete-selection-mode 1)
#+end_src
*** 关闭自动生产的保存文件
#+begin_src emacs-lisp
  (setq auto-save-default nil)
#+end_src

** Word Jump
   #+begin_src emacs-lisp
     (use-package avy
       :ensure t
       :after evil
       :config
       (lmm/evil-space-leader-def
         "aml" 'avy-move-line
         "amr" 'avy-move-region
         "acl" 'avy-copy-line
         "acr" 'avy-copy-region
         "aw" 'avy-goto-word-0
         "akl" 'avy-kill-whole-line
         "akr" 'avy-kill-region
         "ayl" 'avy-kill-ring-save-whole-line
         "ayr" 'avy-kill-ring-save-region
         "as" 'avy-isearch
         "ar" 'avy-resume
         "ab" 'avy-pop-mark)
       (defun lmm/avy-goto-word-1-regexp-and-inside-pairs (pairch &optional arg)
         "复制指定位置括号内容并粘贴"
         (interactive (list (read-char "char: " t)
                            current-prefix-arg))
         (avy-goto-word-1 pairch arg)

         (goto-char (nth 1 (syntax-ppss)))
         (set-mark (save-excursion
                     (forward-char 1)
                     (skip-chars-forward " \t\n")
                     (point)))
         (forward-list)
         (backward-char)
         (skip-chars-backward " \t\n")
         (exchange-point-and-mark)

         (call-interactively 'kill-ring-save)
         (avy-pop-mark)
         (yank))
       (defun lmm/avy-copy-paren-insert()
         "复制指定位置括号内容并粘贴"
         (interactive)
         (save-excursion
           (avy-goto-char ?\) current-prefix-arg)
           (evil-yank (car (evil-a-paren)) (cadr (evil-a-paren))))
         (evil-paste-before 1)
         )
       ;; TODO
     (defun lmm/avy-copy-paren-insert(char &optional arg)
       (interactive (list (read-char "char: " t)
                          current-prefix-arg))
       (when (or
              (= char ?\()
              (= char ?\))
              (= char ?\[)
              (= char ?\])
              (= char ?\{)
              (= char ?\})
              (= char ?\")
              )
         (let ((region
               (save-excursion
                 (if (cons (avy-goto-char char arg))
                     ()
                   nil
                     )
                        ))))
         )
       )
     )
   #+end_src

** Goto Last Change
#+begin_src emacs-lisp
  (use-package goto-chg
    :ensure t
    )
#+end_src

** Expand-region
 - 智能选择区域
   #+begin_src emacs-lisp
     (use-package expand-region
       :ensure t
       :bind ("C-=" . er/expand-region)
       )
   #+end_src

** Parenthes Settings
*** Pairs
#+begin_src emacs-lisp
  ;; (when (fboundp 'electric-pair-mode)
  ;;   (add-hook 'after-init-hook 'electric-pair-mode))
  (use-package paredit
    :disabled
    :ensure t
    :config
    (diminish 'paredit-mode " Par")
    (dolist (binding '("C-<left>" "C-<right>" "C-M-<left>" "C-M-<right>" "M-s" "M-?"))
      (define-key paredit-mode-map (read-kbd-macro binding) nil))
    (paredit-mode)
    )
  (use-package elec-pair
    :ensure nil
    :hook
    (after-init-hook . electric-pair-mode)
    ;; org-mode 中存在bug，故关闭
    (org-mode-hook . (lambda ()(electric-pair-local-mode -1)))
    :config
    )
  (use-package smartparens
    :ensure t
    :init
    (setq sp-highlight-wrap-overlay nil
          sp-highlight-pair-overlay nil
          sp-highlight-wrap-tag-overlay nil)
    :hook
    (org-mode-hook . smartparens-mode)
    :bind
    (:map evil-normal-state-map
          (")" . sp-up-sexp)
          ("(" . sp-backward-up-sexp))
    :config
    (require 'smartparens-config))
#+end_src
*** Show Paren Mode
开启括号配对显示
#+begin_src emacs-lisp
  (use-package paren
    :ensure nil
    :hook
    (after-init-hook . show-paren-mode)
    :config
    (setq show-paren-delay 0)
    (set-face-attribute 'show-paren-match nil
                        :underline '(:background "red" :position 0)
                        :background nil
                        :foreground "red"
                        :weight 'bold
                        ))
  ;; (add-hook 'after-init-hook 'show-paren-mode)
  ;; (add-hook 'show-paren-mode-hook (lambda ()
  ;;                                   (define-advice show-paren-function (:around (fn) fix-show-paren-function)
  ;;                                     "Highlight enclosing parens."
  ;;                                     (cond ((looking-at-p "\\s(") (funcall fn))
  ;;                                           (t (save-excursion
  ;;                                                (ignore-errors (backward-up-list))
  ;;                                                (funcall fn)))))
  ;;                                   (custom-set-faces
  ;;                                    `(show-paren-match ((t (:background ,
  ;;                                                            (face-attribute 'default :background)
  ;;                                                            :foreground "red")))))
  ;;                                   ))
#+end_src

** COMMENT Symbol-overlay
   同词高亮显示
   #+begin_src emacs-lisp
     (use-package symbol-overlay
       :ensure t
       :hook
       ((prog-mode-hook html-mode-hook yaml-mode-hook conf-mode-hook) . symbol-overlay-mode)
       :bind
       (:map symbol-overlay-mode-map
             ("M-i" . symbol-overlay-put)
             ("M-I" . symbol-overlay-remove-all)
             ("M-n" . symbol-overlay-jump-next)
             ("M-p" . symbol-overlay-jump-prev)
             )
       )
   #+end_src

** COMMENT Page Break Lines
页面分割线(C-q C-l)
#+begin_src emacs-lisp
  (use-package page-break-lines
    :ensure t
    :hook
    (after-init-hook . global-page-break-lines-mode)
    :diminish page-break-lines-mode)
#+end_src

** COMMENT Browse Kill Ring
剪贴板
#+begin_src emacs-lisp
  (use-package browse-kill-ring
    :ensure t
    :custom
    (browse-kill-ring-separator "\f")
    :bind
    (("M-Y" . browse-kill-ring)
     (:map browse-kill-ring-mode-map
           ("C-g" . browse-kill-ring-quit)
           ("M-n" . browse-kill-ring-forward)
           ("M-p" . browse-kill-ring-previous))
     )
    :config
    (push 'browse-kill-ring-mode page-break-lines-modes)
    )
#+end_src

** COMMENT Iedit -- 多区域同时编辑
#+begin_src emacs-lisp
  (use-package iedit
    :ensure t
    )
#+end_src

** COMMENT Wgrep -- sed交互式编辑缓冲区
#+begin_src emacs-lisp
#+end_src

** Snippet -- 模板补全
#+begin_src emacs-lisp
  (use-package yasnippet
      :ensure t
      :hook
      (prog-mode-hook . yas-minor-mode)
      (org-mode-hook . yas-minor-mode))

  (use-package yasnippet-snippets
    :ensure t
    :after yasnippet)
#+end_src

** Multiple Cursors -- 多光标编辑
#+begin_src emacs-lisp
  (use-package multiple-cursors
    :ensure t
    )
#+end_src

* LANG CONFIG
** Complete Config
*** Company Install
#+begin_src emacs-lisp
  (use-package company
    :ensure t
    :hook
    (after-init-hook . global-company-mode)
    :init
    (setq tab-always-indent 'complete)
    :config
    (dolist (backend '(company-eclim company-semantic))
      (delq backend company-backends))
    (define-key company-active-map (kbd "C-n") 'company-select-next)
    (define-key company-active-map (kbd "C-p") 'company-select-previous)
    (define-key company-active-map (kbd "C-h") nil)
    ;; (define-key company-active-map (kbd "C-g") 'company-above)
    (define-key company-active-map (kbd "C-i") 'company-complete-common)
    (define-key company-active-map (kbd "C-v") 'company-next-page)
    (define-key company-active-map (kbd "M-v") 'company-previous-page)
    (define-key company-active-map (kbd "C-w") nil)
    (define-key company-active-map (kbd "M-<" ) 'company-select-first)
    (define-key company-active-map (kbd "M->" ) 'company-select-last)
    (add-to-list 'completion-styles 'initials t)
    (setq-default company-dabbrev-other-buffers 'all
                  company-tooltip-align-annotations t
                  company-idle-delay 0
                  company-show-numbers nil
                  company-require-match nil
                  company-dabbrev-ignore-case nil
                  company-dabbrev-downcase nil
                  company-tooltip-maximum-width 80
                  company-tooltip-minimum-width 50)
    ;; 优先考虑匹配前缀的候选者
    (setq company-transformers '(company-sort-prefer-same-case-prefix
                                 company-sort-by-occurrence))
    )
  #+end_src
*** Corfu -- other completion tool
#+begin_src emacs-lisp
  (use-package corfu
    :disabled
    :no-require t
    :ensure t
    :bind
    (:map corfu-map
          ("C-n" . corfu-next)
          ("C-p" . corfu-previous)
          ("M-<" . corfu-first)
          ("M->" . corfu-last)))
#+end_src

** Syntax Checking
#+begin_src emacs-lisp
  (use-package flycheck
    :ensure t
    :hook
    (prog-mode-hook . flycheck-mode))
#+end_src

** Lsp Server Config
#+begin_src emacs-lisp
  (use-package lsp-mode
    :ensure t
    :init
    (setq lsp-auto-guess-root nil
          lsp-prefer-flymake nil
          lsp-auto-configure t
          ;; 符号高亮
          lsp-enable-symbol-highlighting nil
          ;; 关闭底部eldoc 提示
          lsp-eldoc-enable-hover nil
          ;; 关闭状态栏提示
          lsp-modeline-code-actions-enable nil
          ;; 关闭状态栏诊断提示
          lsp-modeline-diagnostics-enable nil
          ;; 关闭模板生成
          lsp-enable-snippet nil
          ;; 关闭折叠
          lsp-enable-folding nil
          )
    :hook
    ;; lsp-deferred 等待buffer完全可见后启用 lsp
    ((c-mode-hook python-mode rust-mode) . lsp-deferred)
    (lsp-mode . lsp-enable-which-key-integration)
    :config
    (delq 'company-capf company-backends)
    (add-to-list 'company-backends 'company-capf)
    :commands lsp)

  (use-package lsp-ui
    :ensure t
    :init
    ;; 错误检查提示延迟
    (setq lsp-ui-sideline-delay 0.4
          ;; 操作提示
          lsp-ui-sideline-show-code-actions nil)
    :commands lsp-ui-mode
    :config
    (setq lsp-ui-sideline-actions-icon lsp-ui-sideline-actions-icon-default))

  (use-package eglot
    :disabled
    :no-require t
    :ensure t
    :commands eglot eglot-ensure)
#+end_src

** LANG
*** javascript
#+begin_src
#+end_src
*** rust
#+begin_src emacs-lisp
  (use-package rust-mode
    :ensure t
    :commands rust-mode
    )
  (use-package rustic
    :ensure t
    :mode
    ("\\.rs$" . rustic-mode)
    :init
    ;; (setq rustic-lsp-server 'rls)
    (setq rustic-lsp-client 'lsp)
    :commands rustic-mode
    :config
    (add-hook 'rustic-mode-hook (lambda () (setq-local company-backends '(company-capf
                                                                     (company-yasnippet company-dabbrev-code company-keywords)
                                                                     company-dabbrev
                                                                     company-files
                                                                     ))))
    (setq rustic-indent-method-chain t)
    (setq rustic-babel-format-src-block nil
          rustic-format-trigger nil)
    ;; hook 引入太早容易出现问题
    ;; (remove-hook 'rustic-mode-hook #'flycheck-mode)
    ;; (remove-hook 'rustic-mode-hook #'flymake-mode-off)
    ;; (unless (featurep 'lsp)
    ;;   (add-to-list 'flycheck-checker 'rustic-clippy))
    ;; (when (featurep 'lsp)
    ;;   (setq lsp-rust-analyzer-cargo-watch-command 'clippy)
    ;;   (remove-hook 'rustic-mode-hook #'rustic-setup-lsp)
    ;;   (add-hook 'rustic-mode-local-vars-hook #'rustic-setup-lsp))
    )
#+end_src
*** emacs-lisp
#+begin_src emacs-lisp
  (add-hook 'emacs-lisp-mode-hook (lambda ()
                                    (setq-local company-backends '(company-elisp
                                                                   company-files
                                                                   (company-dabbrev-code company-keywords)
                                                                   company-dabbrev
                                                                   company-capf))))
#+end_src
*** lua
#+begin_src emacs-lisp
  (use-package lua-mode
    :ensure t
    :init
    (add-to-list 'auto-mode-alist '("\\.lua$" . lua-mode))
    (add-to-list 'interpreter-mode-alist '("lua" . lua-mode))
    :commands lua-mode)
#+end_src
*** markdown-mode
#+begin_src emacs-lisp
  (use-package markdown-mode
    :ensure t
    :commands markdown-mode
    :mode
    ("README\\.md\\'" . gfm-mode)
    :init (setq markdown-command "multimarkdown"))
#+end_src

* PROJECT CONFIG
** Projectile Config
#+begin_src emacs-lisp
  (use-package projectile
    :ensure t
    :hook
    (after-init-hook . projectile-mode)
    :init
    (setq-default projectile-mode-line-prefix " Proj")
    :config
    (when (executable-find "rg")
      (setq-default projectile-generic-command "rg --files --hidden"))
    (lmm/evil-space-leader-def
      "pp" 'projectile-switch-project
      "pf" 'projectile-find-file
      "pb" 'projectile-switch-to-buffer
       ))

  (use-package ibuffer-projectile
    :ensure t
    :after projectile)
#+end_src
* DIRED CONFIG
避免在 dired 中前进和后退新建 buffer
#+begin_src emacs-lisp
  (put 'dired-find-alternate-file 'disabled nil)
  (use-package dired
    :ensure nil
    :commands (dired dired-jump)
    :config
    (defun lmm/dired-up-alternate()
      "Dired up directory -- alternate"
      (interactive)
      (if (equal major-mode 'dired-mode)
          (find-alternate-file "..")
        (message "You not in dired-mode")))

    (defun lmm/dired-find-alternate-file-if-directory()
      "dired-mode:
    dired-find-alternate-file if you select is a directory"
      (interactive)
      (if (equal major-mode 'dired-mode)
          (if (file-directory-p (dired-get-filename))
              (dired-find-alternate-file)
            (when (yes-or-no-p "This is a file, you sure open this file?")
              (dired-find-file)))
        (message "You not in dired-mode")))
    (general-define-key
     :states '(normal motion)
     :keymaps 'dired-mode-map
     "h" 'lmm/dired-up-alternate
     "l" 'lmm/dired-find-alternate-file-if-directory))

  ;; (with-eval-after-load 'dired
  ;;   (define-key dired-mode-map (kbd "<return>") 'dired-find-alternate-file)
  ;;   (define-key dired-mode-map (kbd "-") (lambda () (interactive)
  ;;                                          (find-alternate-file ".."))))
  ;; (add-hook 'dired-mode-hook (lambda ()
  ;;                              (define-key evil-normal-state-local-map (kbd "-")
  ;;                                          (lambda () (interactive)
  ;;                                            (find-alternate-file "..")))))
#+end_src
* WITH-EDITOR
#+begin_src emacs-lisp
  ;; 导出环境变量 －－ EDITOR
  (use-package with-editor
    :ensure t
    :hook
    (shell-mode-hook . with-editor-export-editor)
    (eshell-mode-hook . with-editor-export-editor)
    (term-exec-hook . with-editor-export-editor)
    (vterm-mode-hook . with-editor-export-editor)
    :config
    ;; (shell-command-with-editor-mode)
    ;; (define-key (current-global-map)
    ;;             [remap async-shell-command] 'with-editor-async-shell-command)
    ;; (define-key (current-global-map)
    ;;             [remap shell-command] 'with-editor-shell-command)
  )
#+end_src
* ENVIRONMENT SAVE
保存打开过的光标位置
#+begin_src emacs-lisp
  (add-hook 'after-init-hook 'save-place-mode)
#+end_src
保存打开过的文件
#+begin_src emacs-lisp
  (use-package recentf
    :ensure nil
    :hook (after-init-hook . recentf-mode)
    :init
    (setq recentf-max-saved-items 100))
#+end_src

* GIT
#+begin_src emacs-lisp
  (use-package magit
    :ensure t
    :init
    (setq-default magit-diff-refine-hunk t)
    :commands magit-status magit-dispatch
    :bind
    (:map lmm/evil-space-leader-def-map
          ("gd" . magit-dispatch)
          ("gs" . magit-stage))
    )
#+end_src

* DIFF
#+begin_src emacs-lisp
  (use-package diff-hl
    :ensure t
    :hook
    (after-init-hook . global-diff-hl-mode)
    (dired-mode-hook . diff-hl-dired-mode-unless-remote)
    (magit-pre-refresh-hook . diff-hl-magit-pre-refresh)
    (magit-post-refresh-hook . diff-hl-magit-post-refresh))
#+end_src

* WORKSPACE
** Perspective
#+begin_src emacs-lisp
  (use-package perspective
    :ensure t
    :init
    ;; 按最近使用排序buffer
    (setq persp-sort 'access
          ;; 是否在modeline中显示
          persp-show-modestring t)
    ;; :hook
    ;; (after-init-hook . persp-mode)
    :after consult
    :config
    (progn
      (persp-mode t)
      ;; consult buffers by persp
      (defvar lmm/perspective-consult--source-buffer
        `(:name     ,(format "Buffers ( %s )" (persp-current-name))
                    :narrow   ?b
                    :category buffer
                    :face     consult-buffer
                    :history  buffer-name-history
                    :state    ,#'consult--buffer-state
                    :default  t
                    :items
                    ,(lambda ()(interactive) (persp-current-buffer-names)))
        "Buffer candidate source for `persp-buffers'.")


      (defcustom lmm/perspective-consult-buffer-sources
        '(lmm/perspective-consult--source-buffer
          consult--source-recent-file
          consult--source-bookmark
          consult--source-project-buffer
          consult--source-project-recent-file)
        "Sources used by `consult-buffer'.
  See also `consult-project-buffer-sources'.
  See `consult--multi' for a description of the source data structure."
        :type '(repeat symbol))

      (general-define-key
       :keymaps 'perspective-map
       "<tab>" 'persp-switch
       "d" (lambda ()(interactive)(persp-kill (persp-current-name))))
      (lmm/evil-space-leader-def
        ;; "," (lambda ()(interactive)(consult-buffer lmm/perspective-consult-buffer-sources))
        "," 'persp-switch-to-buffer*
        "<" 'persp-switch-to-buffer
        "<tab>" perspective-map)
      ))
#+end_src
** COMMENT Install Persp
#+begin_src emacs-lisp
  (use-package persp-mode
    :disabled
    :no-require t
    :ensure t
    :after evil
    :init
    (setq persp-autokill-buffer-on-remove 'kill-weak
          persp-reset-windows-on-nil-window-conf nil
          persp-nil-hidden t
          persp-set-last-persp-for-new-frames t
          persp-switch-to-added-buffer nil
          persp-kill-foreign-buffer-behaviour 'kill
          persp-remove-buffers-from-nil-persp-behaviour nil
          persp-auto-resume-time -1 ; Don't auto-load on startup
          )
    :config
    (persp-mode 1)
    (lmm/evil-space-leader-def
      "<tab>" 'persp-key-map
      "," 'persp-switch-to-buffer
      "<" 'switch-to-buffer)
    (general-define-key
     :keymaps 'persp-key-map
     "n" 'persp-window-switch))
#+end_src
** COMMENT Hack Persp
#+begin_src emacs-lisp
  (use-package persp-mode
    :ensure nil
    :config
    (progn

      ;; progn start:

      (defvar lmm/workspace-main-name "main")


      (defun lmm/get-current-workspace-name ()
        "Get current workspace in persp-mode"
        (safe-persp-name (get-current-persp)))

      (defun lmm/get-workspace-names ()
        "Get all workspace name"
        persp-names-cache)


      (defun lmm/workspace-delete(name)
        "删除当前工作区，如果加上 C-u 前缀，从 minibuffer 读取。"
        (interactive
         (let ((current-name (lmm/get-current-workspace-name)))
           (list
            (if current-prefix-arg
                (completing-read (format "Delete workspace (default: %s): " current-name)
                                 (lmm/get-workspace-names)
                                 nil nil nil nil current-name)
              current-name))))
        (let ((workspaces (lmm/get-workspace-names)))
          (if (not (member name workspaces))
              (message (format "Warning: '%s' workspace delete filed" name))
            (persp-kill name))))

      (defun lmm/init-startup-workspace (&rest _)
        "启动时的主工作区"
        (when persp-mode
          (let (persp-before-switch-functions)
            ;; 尝试删除默认无工作区时的 "none"
            (when (equal (car persp-names-cache) persp-nil-name)
              (pop persp-names-cache))
            ;; 当存在主工作区时或工作区大于2时不重复添加主工作区
            (unless (or (member lmm/workspace-main-name persp-names-cache)
                        (> (hash-table-count *persp-hash*) 2))
              (persp-add-new lmm/workspace-main-name)))))

      (defun lmm/init-main-workspace-if-workspace-nil (&rest _)
        "如果主工作区不存在，则创建并切换至主工作区."
        (when persp-mode
          (dolist (frame (frame-list))
            (when (string= (safe-persp-name (get-current-persp frame)) persp-nil-name)
              ;; 是否最后工作区，不是就删除当前工作区并至切换下一个，否则创建主工作区
              (persp-frame-switch (or (cadr (hash-table-keys *persp-hash*))
                                      lmm/workspace-main-name)
                                  frame)))))
      ;; progn end:
      )


    (add-hook 'persp-mode-hook #'lmm/init-startup-workspace)
    (add-hook 'persp-mode-hook #'lmm/init-main-workspace-if-workspace-nil)
    (add-hook 'persp-after-load-state-functions 'lmm/init-main-workspace-if-workspace-nil)
    (add-hook 'persp-before-deactivate-functions 'lmm/init-main-workspace-if-workspace-nil)

    (general-define-key
     :keymaps 'persp-key-map
     "d" 'lmm/workspace-delete)
    )

#+end_src
** Treemacs -- 文件树
#+begin_src emacs-lisp
  (use-package treemacs
    :ensure t
    :defer t
    :bind
    (:map lmm/evil-space-leader-def-map
          (";" . treemacs-select-window)))
  (use-package treemacs-evil
    :ensure t
    :after (treemacs evil))

  (use-package treemacs-icons-dired
    :ensure t
    :hook
    (dired-mode-hook . treemacs-icons-dired-enable-once))
#+end_src

* POPUP
#+begin_src emacs-lisp
  (use-package popup
    :ensure t
    :no-require t)
#+end_src

* UTILS
** 翻译
#+begin_src emacs-lisp
  (defun lmm/translate-word-at-point (p)
    (interactive "P")
    (let ((word (word-at-point p))
          valuestr)
      (if word
          (setq valuestr (shell-command-to-string (concat "sdcv -e -u 朗道英汉字典5.0 " (downcase word))))
        (setq valuestr "word not found at point"))
      (if (featurep 'popup)
          (popup-tip valuestr)
        (message valuestr)))
    )

  ;; C-x 8 RET is insert-char, have unicode
  ;; (defun lmm/consult-display-unicode ()
  ;;   "display unicode by consult"
  ;;   (interactive)
  ;;   (let ((names (ucs-names))
  ;;         (char-alias ()))
  ;;     (maphash (lambda (name char)
  ;;                (push (cons (format "0x%06X\t%s\t%s" char (char-to-string char) name) char) char-alias))
  ;;              names)
  ;;     (completing-read "Unicode Display: " (sort char-alias (lambda (a b)
  ;;                                                             (< (cdr a) (cdr b)))))))
  (defun lmm/rename-buffer-and-file-name(&optional buffer file newfile)
    "Rename current BUFFER name and FILE name for NEWFILE."
    (interactive (let* ((buffer (current-buffer))
                        (file (buffer-file-name))
                        (newfile (and file
                                      (expand-file-name (read-file-name "File and Buffer New Name: ")))))
                   (list buffer file newfile)))
    ;; 读取新文件名
    (if (and buffer file newfile)
        ;; 如果新文件名为文件夹则放弃
        (if (not (directory-name-p newfile))
            (if-let ((newfile-dir (file-name-directory newfile)))
                ;; 判断新文件名所在文件夹是否存在
                (if (file-directory-p newfile-dir)
                    (progn
                      (rename-file file newfile 4)
                      (with-current-buffer buffer
                        ;; 更改缓冲区所在文件路径，同时更改缓冲区名称
                        (set-visited-file-name newfile)
                        ;; (rename-buffer (file-name-nondirectory newfile))
                        ))
                  ;; 是否创建新的文件夹
                  (when (yes-or-no-p
                         (format "\"%s\" directory is not exists, you sure make the new directory?"
                                 newfile-dir))
                    (make-directory newfile-dir)
                    (rename-file file newfile 4)
                    (with-current-buffer buffer
                      (set-visited-file-name newfile)
                      ))))
          (message "\"%s\" is a directory ! ! !" newfile))))


  (use-package evil
    :ensure nil
    :config
    (lmm/evil-space-leader-def
      "tw" 'lmm/translate-word-at-point
      "cf" 'lmm/rename-buffer-and-file-name))

#+end_src
** 文件操作
#+begin_src emacs-lisp
  (defun lmm/open-file-in-remote-sudo(file)
    "Open FILE as remote root"
    (interactive)
    (find-file (if (file-remote-p file)
                   (concat "/" (file-remote-p file 'method) ":"
                           (file-remote-p file 'user) "@" (file-remote-p file 'host)
                           "|sudo:root@"
                           (file-remote-p file 'host) ":" (file-remote-p file 'localname))
                 (user-error "This is not remote file"))))


  (defvar lmmv/sudo-localhost "/sudo:root@localhost:"
    "Sudo localhost name")

  (defun lmm/open-file-in-localhost-sudo(file)
    "Open FILE as root"
    (interactive)
    (find-file (concat lmmv/sudo-localhost (expand-file-name file))))

  (defun lmm/conver-sudo-file-name(file)
    "Conver FILE to sudo path"
    (concat lmmv/sudo-localhost (expand-file-name file)))

  (defun lmm/sudo-find-file (file)
    "Open FILE as root."
    (interactive "FOpen file as root: ")
    (let ((file (expand-file-name file)))
      (cond
       ;; 如果是一个文件夹并存在
       ((file-directory-p file)
        (lmm/read-char-choice
            (format "\"%s\" is directory, sure open in sudo('y' -> yes, '.' -> not sudo open, 'n' or 'q' -> quit)" file)
          ((?y (lmm/open-file-in-localhost-sudo file))
           (?. (find-file file))
           (?n nil)
           (?q nil))))

       ;; 如果是一个文件夹但不存在
       ((directory-name-p file)
        (lmm/read-char-choice
            (format "\"%s\" is new directory, sure make it on sudo('y':make sudo + sudo open, '.':make + open, 'r':make sudo, 'u':make, 'n'|'q':quit)?" file)
          ((?y (let ((fs (lmm/conver-sudo-file-name file)))
                 (make-directory fs t)
                 (if (file-directory-p fs)
                     (find-file fs)
                   (user-error (format "\"%s create filed!\"" file)))))
           (?. (make-directory file t)
               (if (file-directory-p file)
                     (find-file file)
                 (user-error (format "\"%s create filed!\"" file))))
           (?r (make-directory (lmm/conver-sudo-file-name file) t))
           (?u (make-directory file t))
           (?n nil)
           (?q nil))))

       ;; 如果是一个文件并直接可写
       ((file-writable-p file)
        (lmm/read-char-choice
            (format "File \"%s\" is user writeable, sure open in sudo('y':sudo open, '.':open, 'n'|'q':quit)?" file)
          ((?y (lmm/open-file-in-localhost-sudo file))
           (?. (find-file file))
           (?n nil)
           (?q nil))))

       ;; 如果是一个文件并不能直接可写
       ((file-exists-p file) (lmm/open-file-in-localhost-sudo file))

       ;; 如果该文件不存在
       (t nil)
       )))
#+end_src

* KEY LIST
+ word case
  - M-u upcase-dwim 转换单词或者标记区域为大写
  - C-U capitalize-dwim 转换单词或者标记区域所有单词首个字母为大写
